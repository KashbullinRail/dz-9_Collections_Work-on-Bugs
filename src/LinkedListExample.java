
//
//    public void add(int index, E element) {          передаем значение полей в метод
//        checkPositionIndex(index);                    проверяем переданный индекс на границы от нуля до size
//
//        if (index == size)                             если индекс равен размеру списка
//            linkLast(element);                         то передаем новый элемент в метод linkLast которпый добавляет в конец списка
//        else                                           в противном случае
//            linkBefore(element, node(index));          в метод linkBefore который вставляет между элементами списка
//    }
//
//        void linkLast(E e) {                                  принемаем в метод значение поля
//        final Node<E> l = last;                               присваиваем ссылку на последний элемент
//        final Node<E> newNode = new Node<>(l, e, null);       передаем конструктору класса Node значения, где ссылка на следующий элемент null - последний
//                last = newNode;                               перепривязка ссылок о последнем элементе
//                if (l == null)                                если ссылка на предыдущий элемент null
//                first = newNode;                              то определение элемента как первого
//                else
//                l.next = newNode;                             в противном случае элемент перепривязываем ссылки предыдущего элемента о следующем
//                size++;                                       увеличиваем переменную размера списка на один
//                modCount++;                                   фиксируем что произведено изменение
//                }
//
//           void linkBefore(E e, Node<E> succ) {               принимаем в метод значение поля c проверкой границ переданного index
//        // assert succ != null;
//        final Node<E> pred = succ.prev;                       кладем в pred ссылку на предыдущий элемент
//        final Node<E> newNode = new Node<>(pred, e, succ);    передаем значения в конструктор класса Node
//                succ.prev = newNode;                          задаем ссылку предыдущего элемента о добавляемом
//                if (pred == null)                             если предыдущего элемента нет
//                first = newNode;                              то добавляемый элемент первый
//                else
//                pred.next = newNode;                          в противном случае элемент следующий в списке
//                size++;                                       увеличиваем переменную размера списка на один
//                modCount++;                                   фиксируем что произведено изменение
//                }

//    public E set(int index, E element) {                  принемаем поля в метод производящий замены элемента на переданный
//        checkElementIndex(index);                         проверяем переданный индекс на границы от нуля до (size-1)
//        Node<E> x = node(index);                          принемаем значение возвращаемое node
//        E oldVal = x.item;                                промежуточно сохраняем заменяемый элемент списка
//        x.item = element;                                 заменяем его новым элементом
//        return oldVal;                                    возвращаем замененный элемент
//    }
//          Node<E> node(int index) {
//        // assert isElementIndex(index);
//        if (index < (size >> 1)) {                            если индекс в первой половине списка
//            Node<E> x = first;                                определяем как индекс первого элемента
//            for (int i = 0; i < index; i++)                   проходим циклом от начала списка до переданного индекса
//                x = x.next;                                   перебираем по порядку ссылки на следующие элементы списка
//            return x;                                         возвращаем последнюю ссылку на следующий элемент
//        } else {
//            Node<E> x = last;                                 иначе определяем как индекс последнего элемента
//            for (int i = size - 1; i > index; i--)            проходим циклом от конца списка к переданному индексу
//                x = x.prev;                                   перебираем по порядку ссылки на предыдущие элементы списка
//            return x;                                         возвращаем последнюю ссылку на предыдущий элемент
//        }
//    }
//        public E remove ( int index){
//            checkElementIndex(index);                         проверяем переданный индекс на границы от нуля до (size-1)
//            return unlink(node(index));                       передаем индекс в метод и возвращаем результат этого метода
//        }
//        E unlink (Node < E > x) {
//            // assert x != null;
//            final E element = x.item;                         значение удаляемого элемента списка
//            final LinkedList.Node<E> next = x.next;           ссылка удаляемого элемента на следующий элемент
//            final LinkedList.Node<E> prev = x.prev;           ссылка удаляемого элемента на предыдущий элемент
//            if (prev == null) {                               если ссылка на предыдущий элемент null
//                first = next;                                 то определяем ссылку на следующий элемент как первого элемента в списке
//            } else {
//                prev.next = next;                             иначе ссылка предыдущего элемента о последующем принимает ссылку удаляемого
//                x.prev = null;                                а ссылка данного элемента удаляется
//            }
//            if (next == null) {                               если ссылка на следующий элемент null
//                last = prev;                                  то определяем ссылку на следующий элемент как последнего элемента в списке
//            } else {
//                next.prev = prev;                             иначе ссылка последующего элемента на предыдущий принемает ссылку удаляемого
//                x.next = null;                                а ссылка данного элемента удаляется
//            }
//            x.item = null;                                    удаляется значение удаляемого элемента
//            size--;                                           размер списка уменьшается на один
//            modCount++;                                       фиксируем что произведено изменение
//            return element;                                   возвращается значение удаленного элемента
//        }
//
//        public E get ( int index){
//            checkElementIndex(index);                         проверяем переданный индекс на границы от нуля до (size-1)
//            return node(index).item;                          передаем индекс методу node класса Node и возвращаем значение индекса списка
//        }
//
//     public void clear () {
//         for (LinkedList.Node<E> x = first; x != null; ) {    проходим циклом по всем элементам списка
//              LinkedList.Node<E> next = x.next;               при каждой проходке перепривязываем ссылки на следующий элемент списка
//              x.item = null;                                  удаляем значение элемента
//              x.next = null;                                  удаляем ссылку на следующий элемент
//              x.prev = null;                                  удаляем ссылку на предыдущий улемент
//              x = next;                                       следующий элемент принемаем как текущий
//            }
//            first = last = null;                              удаляем определение первого и последнего элеммента списка
//            size = 0;                                         переменной размерности списка присваиваем 0
//            modCount++;                                       фиксируем что произведено изменение
//        }

